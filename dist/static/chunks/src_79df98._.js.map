{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/app/GanttChart.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { Bar } from \"react-chartjs-2\";\nimport { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ChartOptions } from \"chart.js\";\nimport { Result } from \"../types/process\";\nimport { motion } from \"framer-motion\";\n\nChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);\n\nconst GanttChart = ({ algorithm, result }: { algorithm: string, result: Result }) => {\n  const [currentTimeline, setCurrentTimeline] = useState<{ time: number, process: number }[]>([]);\n  const [currentStep, setCurrentStep] = useState<number>(0);\n\n  useEffect(() => {\n    if (result) {\n      setCurrentTimeline(result.timeline);\n      setCurrentStep(0);\n    }\n  }, [result]);\n\n  useEffect(() => {\n    if (currentTimeline.length > 0 && currentStep < currentTimeline.length) {\n      const timer = setTimeout(() => {\n        setCurrentStep((prevStep) => prevStep + 1);\n      }, 1000); // Update every second\n\n      return () => clearTimeout(timer);\n    }\n  }, [currentStep, currentTimeline]);\n\n  const generateGanttChartData = (timeline: { time: number, process: number }[]) => {\n    const labels: string[] = [];\n    const data: { x: [number, number]; y: string }[] = [];\n\n    let lastTime = 0;\n\n    timeline.forEach((entry) => {\n      const processId = entry.process;\n      const currentTime = entry.time;\n\n      const label = processId === 0 ? \"Idle\" : `P${processId}`;\n\n      // Add process label to the list if not already added\n      if (!labels.includes(label)) {\n        labels.push(label);\n      }\n\n      data.push({\n        x: [lastTime, currentTime],\n        y: label,\n      });\n\n      lastTime = currentTime;\n    });\n\n    return { labels, data };\n  };\n\n  const chartData = (timeline: { time: number, process: number }[]) => {\n    if (timeline.length === 0) return { labels: [], datasets: [] }; // Ensure timeline is available\n\n    const { labels, data } = generateGanttChartData(timeline);\n\n    return {\n      labels,\n      datasets: [\n        {\n          label: \"Process Execution Time\",\n          data,\n          backgroundColor: (context: any) => {\n            const label = context.raw.y;\n            return label === \"Idle\" ? \"rgba(200, 200, 200, 0.8)\" : \"rgba(52, 152, 219, 0.8)\"; // Gray for Idle, Blue for processes\n          },\n          borderColor: \"#fff\",\n          borderWidth: 1,\n          barThickness: 20,\n        },\n      ],\n    };\n  };\n\n  const chartOptions: ChartOptions<'bar'> = {\n    indexAxis: \"y\",\n    scales: {\n      x: {\n        type: \"linear\",\n        position: \"bottom\",\n        min: 0,\n        ticks: {\n          stepSize: 1,\n        },\n      },\n    },\n    responsive: true,\n    plugins: {\n      legend: { display: false },\n      tooltip: {\n        callbacks: {\n          label: (context: any) => {\n            const { raw } = context;\n            return `Start: ${raw.x[0]}, End: ${raw.x[1]}`;\n          },\n        },\n      },\n    },\n  };\n\n  return (\n    <div style={{ width: \"80%\", margin: \"auto\", paddingTop: \"20px\" }}>\n      <h2 style={{ color: \"#fff\", textAlign: \"center\" }}>{algorithm} Gantt Chart</h2>\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        transition={{ duration: 1 }}\n      >\n        <Bar data={chartData(currentTimeline.slice(0, currentStep))} options={chartOptions} />\n      </motion.div>\n    </div>\n  );\n};\n\nexport default GanttChart;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/app/Table.tsx"],"sourcesContent":["import React from 'react';\nimport { Process } from '../types/process';\n\ninterface TableProps {\n  processes: Process[];\n}\n\nconst Table: React.FC<TableProps> = ({ processes }) => {\n  return (\n    <div style={{ width: '80%', margin: 'auto', paddingTop: '20px' }}>\n      <h2 style={{ color: '#fff', textAlign: 'center' }}>Processes Table</h2>\n      <table style={{ width: '100%', borderCollapse: 'collapse', color: '#fff' }}>\n        <thead>\n          <tr>\n            <th style={{ border: '1px solid #fff', padding: '8px' }}>PID</th>\n            <th style={{ border: '1px solid #fff', padding: '8px' }}>Arrival Time</th>\n            <th style={{ border: '1px solid #fff', padding: '8px' }}>Burst Time</th>\n          </tr>\n        </thead>\n        <tbody>\n          {processes.map((process) => (\n            <tr key={process.pid}>\n              <td style={{ border: '1px solid #fff', padding: '8px' }}>{process.pid}</td>\n              <td style={{ border: '1px solid #fff', padding: '8px' }}>{process.arrivalTime}</td>\n              <td style={{ border: '1px solid #fff', padding: '8px' }}>{process.burstTime}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default Table;"],"names":[],"mappings":";;;;;AAOA,MAAM,QAA8B,CAAC,EAAE,SAAS,EAAE;IAChD,qBACE,6LAAC;QAAI,OAAO;YAAE,OAAO;YAAO,QAAQ;YAAQ,YAAY;QAAO;;0BAC7D,6LAAC;gBAAG,OAAO;oBAAE,OAAO;oBAAQ,WAAW;gBAAS;0BAAG;;;;;;0BACnD,6LAAC;gBAAM,OAAO;oBAAE,OAAO;oBAAQ,gBAAgB;oBAAY,OAAO;gBAAO;;kCACvE,6LAAC;kCACC,cAAA,6LAAC;;8CACC,6LAAC;oCAAG,OAAO;wCAAE,QAAQ;wCAAkB,SAAS;oCAAM;8CAAG;;;;;;8CACzD,6LAAC;oCAAG,OAAO;wCAAE,QAAQ;wCAAkB,SAAS;oCAAM;8CAAG;;;;;;8CACzD,6LAAC;oCAAG,OAAO;wCAAE,QAAQ;wCAAkB,SAAS;oCAAM;8CAAG;;;;;;;;;;;;;;;;;kCAG7D,6LAAC;kCACE,UAAU,GAAG,CAAC,CAAC,wBACd,6LAAC;;kDACC,6LAAC;wCAAG,OAAO;4CAAE,QAAQ;4CAAkB,SAAS;wCAAM;kDAAI,QAAQ,GAAG;;;;;;kDACrE,6LAAC;wCAAG,OAAO;4CAAE,QAAQ;4CAAkB,SAAS;wCAAM;kDAAI,QAAQ,WAAW;;;;;;kDAC7E,6LAAC;wCAAG,OAAO;4CAAE,QAAQ;4CAAkB,SAAS;wCAAM;kDAAI,QAAQ,SAAS;;;;;;;+BAHpE,QAAQ,GAAG;;;;;;;;;;;;;;;;;;;;;;AAUhC;KAxBM;uCA0BS"}},
    {"offset": {"line": 342, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/app/BarChart.tsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { Bar } from 'react-chartjs-2';\nimport { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend } from 'chart.js';\nimport { Result } from '../types/process';\n\nChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);\n\ninterface BarChartProps {\n    results: { [key: string]: Result };\n    waitTimeChartRef: React.RefObject<HTMLCanvasElement | null>;\n    turnaroundTimeChartRef: React.RefObject<HTMLCanvasElement | null>;\n  }\n\nconst BarChart: React.FC<BarChartProps> = ({ results, waitTimeChartRef, turnaroundTimeChartRef }) => {\n  const waitTimeChartInstanceRef = useRef<ChartJS<'bar'> | null>(null);\n  const turnaroundTimeChartInstanceRef = useRef<ChartJS<'bar'> | null>(null);\n\n  useEffect(() => {\n    if (waitTimeChartInstanceRef.current) {\n      waitTimeChartRef.current = waitTimeChartInstanceRef.current.canvas;\n    }\n    if (turnaroundTimeChartInstanceRef.current) {\n      turnaroundTimeChartRef.current = turnaroundTimeChartInstanceRef.current.canvas;\n    }\n  }, [waitTimeChartRef, turnaroundTimeChartRef]);\n\n  const algorithms = Object.keys(results);\n  const averageWaitTimes = algorithms.map(algorithm => results[algorithm].AverageWaitTime);\n  const averageTurnaroundTimes = algorithms.map(algorithm => results[algorithm].AverageTurnAroundTime);\n\n  const colors = [\n    'rgba(75, 192, 192, 0.6)',\n    'rgba(153, 102, 255, 0.6)',\n    'rgba(255, 159, 64, 0.6)',\n    'rgba(255, 99, 132, 0.6)',\n    'rgba(54, 162, 235, 0.6)',\n  ];\n\n  const waitTimeData = {\n    labels: algorithms,\n    datasets: [\n      {\n        label: 'Average Wait Time',\n        data: averageWaitTimes,\n        backgroundColor: colors,\n        borderColor: colors.map(color => color.replace('0.6', '1')),\n        borderWidth: 1,\n      },\n    ],\n  };\n\n  const turnaroundTimeData = {\n    labels: algorithms,\n    datasets: [\n      {\n        label: 'Average Turnaround Time',\n        data: averageTurnaroundTimes,\n        backgroundColor: colors,\n        borderColor: colors.map(color => color.replace('0.6', '1')),\n        borderWidth: 1,\n      },\n    ],\n  };\n\n  const options = {\n    responsive: true,\n    plugins: {\n      legend: {\n        position: 'top' as const,\n      },\n      title: {\n        display: true,\n        text: '',\n      },\n    },\n  };\n\n  return (\n    <div style={{ width: '80%', margin: 'auto', paddingTop: '20px', display: 'flex', justifyContent: 'space-between' }}>\n      <div style={{ width: '45%' }}>\n        <Bar ref={waitTimeChartInstanceRef} data={waitTimeData} options={{ ...options, plugins: { ...options.plugins, title: { ...options.plugins.title, text: 'Average Wait Time by Algorithm' } } }} />\n      </div>\n      <div style={{ width: '45%' }}>\n        <Bar ref={turnaroundTimeChartInstanceRef} data={turnaroundTimeData} options={{ ...options, plugins: { ...options.plugins, title: { ...options.plugins.title, text: 'Average Turnaround Time by Algorithm' } } }} />\n      </div>\n    </div>\n  );\n};\n\nexport default BarChart;"],"names":[],"mappings":";;;;AAAA;AAEA;AADA;;;;;;AAIA,+JAAA,CAAA,QAAO,CAAC,QAAQ,CAAC,+JAAA,CAAA,gBAAa,EAAE,+JAAA,CAAA,cAAW,EAAE,+JAAA,CAAA,aAAU,EAAE,+JAAA,CAAA,QAAK,EAAE,+JAAA,CAAA,UAAO,EAAE,+JAAA,CAAA,SAAM;AAQ/E,MAAM,WAAoC,CAAC,EAAE,OAAO,EAAE,gBAAgB,EAAE,sBAAsB,EAAE;;IAC9F,MAAM,2BAA2B,CAAA,GAAA,6JAAA,CAAA,SAAM,AAAD,EAAyB;IAC/D,MAAM,iCAAiC,CAAA,GAAA,6JAAA,CAAA,SAAM,AAAD,EAAyB;IAErE,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;8BAAE;YACR,IAAI,yBAAyB,OAAO,EAAE;gBACpC,iBAAiB,OAAO,GAAG,yBAAyB,OAAO,CAAC,MAAM;YACpE;YACA,IAAI,+BAA+B,OAAO,EAAE;gBAC1C,uBAAuB,OAAO,GAAG,+BAA+B,OAAO,CAAC,MAAM;YAChF;QACF;6BAAG;QAAC;QAAkB;KAAuB;IAE7C,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,mBAAmB,WAAW,GAAG,CAAC,CAAA,YAAa,OAAO,CAAC,UAAU,CAAC,eAAe;IACvF,MAAM,yBAAyB,WAAW,GAAG,CAAC,CAAA,YAAa,OAAO,CAAC,UAAU,CAAC,qBAAqB;IAEnG,MAAM,SAAS;QACb;QACA;QACA;QACA;QACA;KACD;IAED,MAAM,eAAe;QACnB,QAAQ;QACR,UAAU;YACR;gBACE,OAAO;gBACP,MAAM;gBACN,iBAAiB;gBACjB,aAAa,OAAO,GAAG,CAAC,CAAA,QAAS,MAAM,OAAO,CAAC,OAAO;gBACtD,aAAa;YACf;SACD;IACH;IAEA,MAAM,qBAAqB;QACzB,QAAQ;QACR,UAAU;YACR;gBACE,OAAO;gBACP,MAAM;gBACN,iBAAiB;gBACjB,aAAa,OAAO,GAAG,CAAC,CAAA,QAAS,MAAM,OAAO,CAAC,OAAO;gBACtD,aAAa;YACf;SACD;IACH;IAEA,MAAM,UAAU;QACd,YAAY;QACZ,SAAS;YACP,QAAQ;gBACN,UAAU;YACZ;YACA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF;IACF;IAEA,qBACE,6LAAC;QAAI,OAAO;YAAE,OAAO;YAAO,QAAQ;YAAQ,YAAY;YAAQ,SAAS;YAAQ,gBAAgB;QAAgB;;0BAC/G,6LAAC;gBAAI,OAAO;oBAAE,OAAO;gBAAM;0BACzB,cAAA,6LAAC,yJAAA,CAAA,MAAG;oBAAC,KAAK;oBAA0B,MAAM;oBAAc,SAAS;wBAAE,GAAG,OAAO;wBAAE,SAAS;4BAAE,GAAG,QAAQ,OAAO;4BAAE,OAAO;gCAAE,GAAG,QAAQ,OAAO,CAAC,KAAK;gCAAE,MAAM;4BAAiC;wBAAE;oBAAE;;;;;;;;;;;0BAE9L,6LAAC;gBAAI,OAAO;oBAAE,OAAO;gBAAM;0BACzB,cAAA,6LAAC,yJAAA,CAAA,MAAG;oBAAC,KAAK;oBAAgC,MAAM;oBAAoB,SAAS;wBAAE,GAAG,OAAO;wBAAE,SAAS;4BAAE,GAAG,QAAQ,OAAO;4BAAE,OAAO;gCAAE,GAAG,QAAQ,OAAO,CAAC,KAAK;gCAAE,MAAM;4BAAuC;wBAAE;oBAAE;;;;;;;;;;;;;;;;;AAItN;GA1EM;KAAA;uCA4ES"}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 508, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/utilities/PDF.ts"],"sourcesContent":["import { jsPDF } from \"jspdf\";\n\nexport const PDF = (waitTimeChart: HTMLCanvasElement | null, turnaroundTimeChart: HTMLCanvasElement | null) => {\n    const doc = new jsPDF();\n\n    doc.setFontSize(14);\n\n    let currentY = 30;\n\n    if (waitTimeChart) {\n        const waitTimeImage = waitTimeChart.toDataURL(\"image/png\");\n        doc.addImage(waitTimeImage, 'PNG', 14, currentY, 180, 90);\n        currentY += 100;\n    }\n\n    if (turnaroundTimeChart) {\n        const turnaroundTimeImage = turnaroundTimeChart.toDataURL(\"image/png\");\n        doc.addImage(turnaroundTimeImage, 'PNG', 14, currentY, 180, 90);\n    }\n\n    doc.save(\"results.pdf\");\n};"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,MAAM,CAAC,eAAyC;IACzD,MAAM,MAAM,IAAI,sJAAA,CAAA,QAAK;IAErB,IAAI,WAAW,CAAC;IAEhB,IAAI,WAAW;IAEf,IAAI,eAAe;QACf,MAAM,gBAAgB,cAAc,SAAS,CAAC;QAC9C,IAAI,QAAQ,CAAC,eAAe,OAAO,IAAI,UAAU,KAAK;QACtD,YAAY;IAChB;IAEA,IAAI,qBAAqB;QACrB,MAAM,sBAAsB,oBAAoB,SAAS,CAAC;QAC1D,IAAI,QAAQ,CAAC,qBAAqB,OAAO,IAAI,UAAU,KAAK;IAChE;IAEA,IAAI,IAAI,CAAC;AACb;KAnBa"}},
    {"offset": {"line": 534, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/utilities/processGenerator.ts"],"sourcesContent":["import { Process } from \"../types/process\";\n\n//this makes a random number of processes with random features\n//returns an array of processes to be processed by the scheduling algorithms\n\nexport function generateProcesses(count:number) : Process[]\n{\n    const MaxBurst = 7;\n    const MaxArrival = 7;\n    let burstTime = 0; // need a variable so that remaining time and burst time are the sae\n\n    const processes: Process[] = [];\n\n    for(let i = 0; i < count; i++)\n    {\n        burstTime = Math.floor(Math.random() * MaxBurst) + 1;\n        processes.push({pid: i+1, \n                        arrivalTime: Math.floor(Math.random() * MaxArrival) + 1, \n                        burstTime: burstTime,\n                        completed: false,\n                        remainingTime: burstTime,\n                        queuelevel: 0});\n    }\n    console.log(\"Generated Processes: \", processes); // Debugging log\n    return processes\n}\n"],"names":[],"mappings":";;;AAKO,SAAS,kBAAkB,KAAY;IAE1C,MAAM,WAAW;IACjB,MAAM,aAAa;IACnB,IAAI,YAAY,GAAG,oEAAoE;IAEvF,MAAM,YAAuB,EAAE;IAE/B,IAAI,IAAI,IAAI,GAAG,IAAI,OAAO,IAC1B;QACI,YAAY,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,YAAY;QACnD,UAAU,IAAI,CAAC;YAAC,KAAK,IAAE;YACP,aAAa,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,cAAc;YACtD,WAAW;YACX,WAAW;YACX,eAAe;YACf,YAAY;QAAC;IACjC;IACA,QAAQ,GAAG,CAAC,yBAAyB,YAAY,gBAAgB;IACjE,OAAO;AACX"}},
    {"offset": {"line": 565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/algorithms/fifo.ts"],"sourcesContent":["import {Process, Result} from \"../types/process\"\n\nexport function FirstInFirstOut(processes: Process[]): Result\n{\n    const result: Result =\n    {\n        timeline: [],\n        AverageWaitTime: 0,\n        AverageTurnAroundTime: 0, \n    };\n    \n    const sorted = processes.sort( (a, b) => a.arrivalTime - b.arrivalTime )\n    \n    const numProcesses = processes.length;\n    let currTime = 0; //for the timeline\n    let TurnAroundTime = 0;\n    let totalWaitTime = 0; //for calculating average wait time late\n    let totalTurnAroundTime = 0; //for calculating average turnaround time later\n\n    for(let i = 0; i < numProcesses; i++)\n    {\n        if(processes[i].arrivalTime > currTime)\n        {\n            currTime = processes[i].arrivalTime;\n            result.timeline.push({time: currTime, process: 0});\n        }\n        processes[i].completed = true;\n        currTime += processes[i].burstTime;\n        result.timeline.push({time: currTime, process: processes[i].pid});\n        \n        //wait time = turnaround time - burst time\n        //turnaround time = completion time - arrival time\n\n        TurnAroundTime = currTime - sorted[i].arrivalTime;\n        totalTurnAroundTime = totalTurnAroundTime + TurnAroundTime;\n        totalWaitTime = totalWaitTime + (TurnAroundTime - sorted[i].burstTime);\n        \n    }\n\n    result.AverageTurnAroundTime = totalWaitTime/numProcesses;\n    result.AverageWaitTime = totalWaitTime/numProcesses;\n\n    return result\n}"],"names":[],"mappings":";;;AAEO,SAAS,gBAAgB,SAAoB;IAEhD,MAAM,SACN;QACI,UAAU,EAAE;QACZ,iBAAiB;QACjB,uBAAuB;IAC3B;IAEA,MAAM,SAAS,UAAU,IAAI,CAAE,CAAC,GAAG,IAAM,EAAE,WAAW,GAAG,EAAE,WAAW;IAEtE,MAAM,eAAe,UAAU,MAAM;IACrC,IAAI,WAAW,GAAG,kBAAkB;IACpC,IAAI,iBAAiB;IACrB,IAAI,gBAAgB,GAAG,wCAAwC;IAC/D,IAAI,sBAAsB,GAAG,+CAA+C;IAE5E,IAAI,IAAI,IAAI,GAAG,IAAI,cAAc,IACjC;QACI,IAAG,SAAS,CAAC,EAAE,CAAC,WAAW,GAAG,UAC9B;YACI,WAAW,SAAS,CAAC,EAAE,CAAC,WAAW;YACnC,OAAO,QAAQ,CAAC,IAAI,CAAC;gBAAC,MAAM;gBAAU,SAAS;YAAC;QACpD;QACA,SAAS,CAAC,EAAE,CAAC,SAAS,GAAG;QACzB,YAAY,SAAS,CAAC,EAAE,CAAC,SAAS;QAClC,OAAO,QAAQ,CAAC,IAAI,CAAC;YAAC,MAAM;YAAU,SAAS,SAAS,CAAC,EAAE,CAAC,GAAG;QAAA;QAE/D,0CAA0C;QAC1C,kDAAkD;QAElD,iBAAiB,WAAW,MAAM,CAAC,EAAE,CAAC,WAAW;QACjD,sBAAsB,sBAAsB;QAC5C,gBAAgB,gBAAgB,CAAC,iBAAiB,MAAM,CAAC,EAAE,CAAC,SAAS;IAEzE;IAEA,OAAO,qBAAqB,GAAG,gBAAc;IAC7C,OAAO,eAAe,GAAG,gBAAc;IAEvC,OAAO;AACX;KAzCgB"}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/algorithms/sjf.ts"],"sourcesContent":["import {Process, Result} from \"../types/process\"\n\nexport function sjf(processes: Process[]): Result\n{\n    const result: Result =\n    {\n        timeline: [],\n        AverageWaitTime: 0,\n        AverageTurnAroundTime: 0, \n    };\n    const sorted = processes.sort( (a, b) => a.arrivalTime - b.arrivalTime )\n    \n    const numProcesses = sorted.length;\n    let currTime = 0; //for the timeline\n    let WaitTime = 0; //for calculating average wait time late\n    let TurnAroundTime = 0; //for calculating average turnaround time later\n    for(let i = 0; i<numProcesses; i++)\n    {\n        let index = -1;\n        if(sorted[i].arrivalTime >= currTime)\n        {\n            currTime = sorted[i].arrivalTime;\n            result.timeline.push({time: currTime, process: 0});\n        }\n\n        //loop to find process with shortest burst time\n        for(let j = 0; j<numProcesses; j++)\n        {\n            if(sorted[j].arrivalTime <=currTime && !sorted[j].completed)\n            {\n                if(index === -1 || sorted[j].burstTime < sorted[index].burstTime)\n                {\n                    index = j;\n                }\n            }\n        }\n        currTime = currTime + sorted[index].burstTime;\n        result.timeline.push({time: currTime, process: sorted[index].pid});\n\n        //wait time = turnaround time - burst time\n        //turnaround time = completion time - arrival time\n        TurnAroundTime = currTime - sorted[index].arrivalTime;\n        WaitTime = TurnAroundTime - sorted[index].burstTime;\n        result.AverageTurnAroundTime += TurnAroundTime;\n        result.AverageWaitTime += WaitTime;\n\n        sorted[index].completed = true;\n    }\n    result.AverageTurnAroundTime = result.AverageTurnAroundTime/numProcesses;\n    result.AverageWaitTime = result.AverageWaitTime/numProcesses;\n\n    return result\n}"],"names":[],"mappings":";;;AAEO,SAAS,IAAI,SAAoB;IAEpC,MAAM,SACN;QACI,UAAU,EAAE;QACZ,iBAAiB;QACjB,uBAAuB;IAC3B;IACA,MAAM,SAAS,UAAU,IAAI,CAAE,CAAC,GAAG,IAAM,EAAE,WAAW,GAAG,EAAE,WAAW;IAEtE,MAAM,eAAe,OAAO,MAAM;IAClC,IAAI,WAAW,GAAG,kBAAkB;IACpC,IAAI,WAAW,GAAG,wCAAwC;IAC1D,IAAI,iBAAiB,GAAG,+CAA+C;IACvE,IAAI,IAAI,IAAI,GAAG,IAAE,cAAc,IAC/B;QACI,IAAI,QAAQ,CAAC;QACb,IAAG,MAAM,CAAC,EAAE,CAAC,WAAW,IAAI,UAC5B;YACI,WAAW,MAAM,CAAC,EAAE,CAAC,WAAW;YAChC,OAAO,QAAQ,CAAC,IAAI,CAAC;gBAAC,MAAM;gBAAU,SAAS;YAAC;QACpD;QAEA,+CAA+C;QAC/C,IAAI,IAAI,IAAI,GAAG,IAAE,cAAc,IAC/B;YACI,IAAG,MAAM,CAAC,EAAE,CAAC,WAAW,IAAG,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,SAAS,EAC3D;gBACI,IAAG,UAAU,CAAC,KAAK,MAAM,CAAC,EAAE,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,SAAS,EAChE;oBACI,QAAQ;gBACZ;YACJ;QACJ;QACA,WAAW,WAAW,MAAM,CAAC,MAAM,CAAC,SAAS;QAC7C,OAAO,QAAQ,CAAC,IAAI,CAAC;YAAC,MAAM;YAAU,SAAS,MAAM,CAAC,MAAM,CAAC,GAAG;QAAA;QAEhE,0CAA0C;QAC1C,kDAAkD;QAClD,iBAAiB,WAAW,MAAM,CAAC,MAAM,CAAC,WAAW;QACrD,WAAW,iBAAiB,MAAM,CAAC,MAAM,CAAC,SAAS;QACnD,OAAO,qBAAqB,IAAI;QAChC,OAAO,eAAe,IAAI;QAE1B,MAAM,CAAC,MAAM,CAAC,SAAS,GAAG;IAC9B;IACA,OAAO,qBAAqB,GAAG,OAAO,qBAAqB,GAAC;IAC5D,OAAO,eAAe,GAAG,OAAO,eAAe,GAAC;IAEhD,OAAO;AACX"}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/algorithms/rr.ts"],"sourcesContent":["import {Process, Result} from \"../types/process\"\n\nexport function rr(processes: Process[], quantum: number): Result\n{\n    const result: Result =\n    {\n        timeline: [],\n        AverageWaitTime: 0,\n        AverageTurnAroundTime: 0, \n    };\n    const sorted = processes.sort( (a, b) => a.arrivalTime - b.arrivalTime )\n    \n    const numProcesses = sorted.length;\n    let currTime = 0; //for the timeline\n    let TurnAroundTime = 0;\n    let done = false;\n\n    while(done == false)\n    {\n        done = true; \n        for(let i = 0; i<numProcesses; i++)\n        {\n            if(sorted[i].arrivalTime > currTime)\n            {\n                currTime = sorted[i].arrivalTime;\n                result.timeline.push({time: currTime, process: 0});\n                //here will be to indicate idle time\n            }\n\n            if(!sorted[i].completed)\n            {\n                if(sorted[i].remainingTime <= quantum && sorted[i].remainingTime > 0)\n                {\n                    currTime += sorted[i].remainingTime;\n                    sorted[i].remainingTime = 0;\n                    result.timeline.push({time: currTime, process: sorted[i].pid});\n                    sorted[i].completed = true;\n                }\n                else\n                {\n                    sorted[i].remainingTime -= quantum;\n                    currTime += quantum;\n                    result.timeline.push({time: currTime, process: sorted[i].pid});\n                    done = false;\n                }\n\n                //wait time = turnaround time - burst time\n                //turnaround time = completion time - arrival time\n                TurnAroundTime = currTime - sorted[i].arrivalTime;\n                result.AverageTurnAroundTime += currTime - sorted[i].arrivalTime;\n                result.AverageWaitTime += TurnAroundTime - sorted[i].burstTime;\n\n            }\n        }\n    }\n\n    result.AverageTurnAroundTime = result.AverageTurnAroundTime/numProcesses;\n    result.AverageWaitTime = result.AverageWaitTime/numProcesses;\n    return result\n}"],"names":[],"mappings":";;;AAEO,SAAS,GAAG,SAAoB,EAAE,OAAe;IAEpD,MAAM,SACN;QACI,UAAU,EAAE;QACZ,iBAAiB;QACjB,uBAAuB;IAC3B;IACA,MAAM,SAAS,UAAU,IAAI,CAAE,CAAC,GAAG,IAAM,EAAE,WAAW,GAAG,EAAE,WAAW;IAEtE,MAAM,eAAe,OAAO,MAAM;IAClC,IAAI,WAAW,GAAG,kBAAkB;IACpC,IAAI,iBAAiB;IACrB,IAAI,OAAO;IAEX,MAAM,QAAQ,MACd;QACI,OAAO;QACP,IAAI,IAAI,IAAI,GAAG,IAAE,cAAc,IAC/B;YACI,IAAG,MAAM,CAAC,EAAE,CAAC,WAAW,GAAG,UAC3B;gBACI,WAAW,MAAM,CAAC,EAAE,CAAC,WAAW;gBAChC,OAAO,QAAQ,CAAC,IAAI,CAAC;oBAAC,MAAM;oBAAU,SAAS;gBAAC;YAChD,oCAAoC;YACxC;YAEA,IAAG,CAAC,MAAM,CAAC,EAAE,CAAC,SAAS,EACvB;gBACI,IAAG,MAAM,CAAC,EAAE,CAAC,aAAa,IAAI,WAAW,MAAM,CAAC,EAAE,CAAC,aAAa,GAAG,GACnE;oBACI,YAAY,MAAM,CAAC,EAAE,CAAC,aAAa;oBACnC,MAAM,CAAC,EAAE,CAAC,aAAa,GAAG;oBAC1B,OAAO,QAAQ,CAAC,IAAI,CAAC;wBAAC,MAAM;wBAAU,SAAS,MAAM,CAAC,EAAE,CAAC,GAAG;oBAAA;oBAC5D,MAAM,CAAC,EAAE,CAAC,SAAS,GAAG;gBAC1B,OAEA;oBACI,MAAM,CAAC,EAAE,CAAC,aAAa,IAAI;oBAC3B,YAAY;oBACZ,OAAO,QAAQ,CAAC,IAAI,CAAC;wBAAC,MAAM;wBAAU,SAAS,MAAM,CAAC,EAAE,CAAC,GAAG;oBAAA;oBAC5D,OAAO;gBACX;gBAEA,0CAA0C;gBAC1C,kDAAkD;gBAClD,iBAAiB,WAAW,MAAM,CAAC,EAAE,CAAC,WAAW;gBACjD,OAAO,qBAAqB,IAAI,WAAW,MAAM,CAAC,EAAE,CAAC,WAAW;gBAChE,OAAO,eAAe,IAAI,iBAAiB,MAAM,CAAC,EAAE,CAAC,SAAS;YAElE;QACJ;IACJ;IAEA,OAAO,qBAAqB,GAAG,OAAO,qBAAqB,GAAC;IAC5D,OAAO,eAAe,GAAG,OAAO,eAAe,GAAC;IAChD,OAAO;AACX"}},
    {"offset": {"line": 737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/algorithms/stcf.ts"],"sourcesContent":["import { Process, Result } from \"../types/process\";\n\nexport function stcf(processes: Process[]): Result {\n    const result: Result = {\n        timeline: [],\n        AverageWaitTime: 0,\n        AverageTurnAroundTime: 0,\n    };\n    const sorted = processes.sort((a, b) => a.arrivalTime - b.arrivalTime);\n\n    const numProcesses = sorted.length;\n    let currTime = 0; // for the timeline\n    let TurnAroundTime = 0; // for calculating average turnaround time later\n    let completedProcesses = 0;\n    let shortest_index = -1; // index of process with shortest remaining time\n    let currentProcess = -1;\n\n    while (completedProcesses < numProcesses) {\n        shortest_index = -1;\n        for (let i = 0; i < numProcesses; i++) {\n            if (sorted[i].arrivalTime <= currTime && !sorted[i].completed) {\n                if (shortest_index == -1 || sorted[i].remainingTime < sorted[shortest_index].remainingTime) {\n                    shortest_index = i;\n                }\n            }\n        }\n\n        if(shortest_index == -1) \n        {\n            if(shortest_index != currentProcess) //switching from process to idle\n            {\n                result.timeline.push({ time: currTime, process: sorted[currentProcess].pid });\n                sorted[currentProcess].remainingTime -= 1;\n                currentProcess = shortest_index;\n            }\n        }\n        else if (shortest_index != currentProcess)\n        {\n            if(currentProcess == -1) //switching from idle to process\n            {\n                result.timeline.push({ time: currTime, process: 0 });\n            }\n            else //switching from process to process\n            {\n                result.timeline.push({ time: currTime, process: sorted[currentProcess].pid });\n                sorted[currentProcess].remainingTime -= 1;\n            }\n            currentProcess = shortest_index;\n        }\n        else //same process\n        {\n            sorted[currentProcess].remainingTime -= 1;\n        }\n\n        if(currentProcess != -1 && sorted[currentProcess].remainingTime == 0) //process completed\n        {\n            sorted[currentProcess].completed = true;\n            completedProcesses += 1;\n            TurnAroundTime = currTime - sorted[currentProcess].arrivalTime + 1;\n            result.AverageTurnAroundTime += TurnAroundTime;\n            result.AverageWaitTime += TurnAroundTime - sorted[currentProcess].burstTime;\n            result.timeline.push({ time: currTime, process: sorted[currentProcess].pid });\n            continue;\n        }\n\n        currTime += 1;\n    }\n\n    result.AverageTurnAroundTime = result.AverageTurnAroundTime / numProcesses;\n    result.AverageWaitTime = result.AverageWaitTime / numProcesses;\n\n    return result;\n}"],"names":[],"mappings":";;;AAEO,SAAS,KAAK,SAAoB;IACrC,MAAM,SAAiB;QACnB,UAAU,EAAE;QACZ,iBAAiB;QACjB,uBAAuB;IAC3B;IACA,MAAM,SAAS,UAAU,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,WAAW,GAAG,EAAE,WAAW;IAErE,MAAM,eAAe,OAAO,MAAM;IAClC,IAAI,WAAW,GAAG,mBAAmB;IACrC,IAAI,iBAAiB,GAAG,gDAAgD;IACxE,IAAI,qBAAqB;IACzB,IAAI,iBAAiB,CAAC,GAAG,gDAAgD;IACzE,IAAI,iBAAiB,CAAC;IAEtB,MAAO,qBAAqB,aAAc;QACtC,iBAAiB,CAAC;QAClB,IAAK,IAAI,IAAI,GAAG,IAAI,cAAc,IAAK;YACnC,IAAI,MAAM,CAAC,EAAE,CAAC,WAAW,IAAI,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE;gBAC3D,IAAI,kBAAkB,CAAC,KAAK,MAAM,CAAC,EAAE,CAAC,aAAa,GAAG,MAAM,CAAC,eAAe,CAAC,aAAa,EAAE;oBACxF,iBAAiB;gBACrB;YACJ;QACJ;QAEA,IAAG,kBAAkB,CAAC,GACtB;YACI,IAAG,kBAAkB,gBACrB;gBACI,OAAO,QAAQ,CAAC,IAAI,CAAC;oBAAE,MAAM;oBAAU,SAAS,MAAM,CAAC,eAAe,CAAC,GAAG;gBAAC;gBAC3E,MAAM,CAAC,eAAe,CAAC,aAAa,IAAI;gBACxC,iBAAiB;YACrB;QACJ,OACK,IAAI,kBAAkB,gBAC3B;YACI,IAAG,kBAAkB,CAAC,GACtB;gBACI,OAAO,QAAQ,CAAC,IAAI,CAAC;oBAAE,MAAM;oBAAU,SAAS;gBAAE;YACtD,OAEA;gBACI,OAAO,QAAQ,CAAC,IAAI,CAAC;oBAAE,MAAM;oBAAU,SAAS,MAAM,CAAC,eAAe,CAAC,GAAG;gBAAC;gBAC3E,MAAM,CAAC,eAAe,CAAC,aAAa,IAAI;YAC5C;YACA,iBAAiB;QACrB,OAEA;YACI,MAAM,CAAC,eAAe,CAAC,aAAa,IAAI;QAC5C;QAEA,IAAG,kBAAkB,CAAC,KAAK,MAAM,CAAC,eAAe,CAAC,aAAa,IAAI,GACnE;YACI,MAAM,CAAC,eAAe,CAAC,SAAS,GAAG;YACnC,sBAAsB;YACtB,iBAAiB,WAAW,MAAM,CAAC,eAAe,CAAC,WAAW,GAAG;YACjE,OAAO,qBAAqB,IAAI;YAChC,OAAO,eAAe,IAAI,iBAAiB,MAAM,CAAC,eAAe,CAAC,SAAS;YAC3E,OAAO,QAAQ,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAU,SAAS,MAAM,CAAC,eAAe,CAAC,GAAG;YAAC;YAC3E;QACJ;QAEA,YAAY;IAChB;IAEA,OAAO,qBAAqB,GAAG,OAAO,qBAAqB,GAAG;IAC9D,OAAO,eAAe,GAAG,OAAO,eAAe,GAAG;IAElD,OAAO;AACX"}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 821, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/algorithms/mlfq.ts"],"sourcesContent":["import {Process, Result} from \"../types/process\"\n\n/*\n    Rules: \n    1. if prio A > prio B, A runs\n    2. if prio A = prio B, both run in round robin\n    3. processes are placed at highest priority when they arrive\n    4. if a process uses up its allotment, it is moved to the next lower priority\n    5. after some (s) move all processes to the highest priority\n\n    Notes: \n    - 3 queues for this mlfq\n    - priority is based on queue level where 0 is the highest priority\n    - 3rd queue will work as a FCFS queue\n*/\n\nexport function mlfq(processes: Process[]): Result\n{\n    const result: Result =\n    {\n        timeline: [],\n        AverageWaitTime: 0,\n        AverageTurnAroundTime: 0, \n    };\n    const sorted = processes.sort( (a, b) => a.arrivalTime - b.arrivalTime )\n    \n    const numProcesses = sorted.length;\n    let currTime = 0; //for the timeline\n    let TurnAroundTime = 0; //for calculating average turnaround time later\n    let completedProcesses = 0;\n\n    const q1quantum = 2; //quantum for queue 1\n    const q2quantum = 4; //quantum for queue 2\n    const allotment = 4;\n    let s = 20; //after 20 units of time. move all processes to the highest priority\n\n    let lastProcess = 0; //index of the last process that was put into the queue to ensure no duplicate processes\n    const q1: Process[] = [];\n    const q2: Process[] = [];\n    const q3: Process[] = [];\n\n    while(completedProcesses < numProcesses)\n    {\n        for(let i = 0; i<numProcesses; i++)\n        {\n            if(sorted[i].queuelevel == 0 && sorted[i].arrivalTime <= currTime && !sorted[i].completed && i == lastProcess)\n            {\n                q1.push(sorted[i]);\n                lastProcess++;\n            }\n        }\n        let WorkingQueue = 0;;\n        if(q1.length != 0)\n        {\n            WorkingQueue = 0;\n        }\n        else if(q2.length != 0)\n        {\n            WorkingQueue = 1;\n        }\n        else\n        {\n            WorkingQueue = 2;\n        }\n\n        if(WorkingQueue == 0)\n        {\n            if(q1[0].remainingTime <= q1quantum)\n            {\n                currTime += q1[0].remainingTime;\n                s-=q1[0].remainingTime;\n                q1[0].remainingTime = 0;\n                //wait time = turnaround time - burst time\n                //turnaround time = completion time - arrival time\n                TurnAroundTime = currTime - q1[0].arrivalTime;\n                result.AverageTurnAroundTime += currTime - q1[0].arrivalTime;\n                result.AverageWaitTime += TurnAroundTime - q1[0].burstTime;\n\n                result.timeline.push({time: currTime, process: q1[0].pid});\n                q1[0].completed = true;\n                completedProcesses++;\n                q1.shift();\n            }\n            else\n            {\n                currTime += q1quantum;\n                s-=q1quantum;\n                q1[0].remainingTime -= q1quantum;\n                result.timeline.push({time: currTime, process: q1[0].pid});\n                const temp : Process = q1[0];\n                q1.shift();\n                if((temp.burstTime - temp.remainingTime) % allotment == 0)\n                {\n                    temp.queuelevel++;\n                    q2.push(temp);\n                }\n                else\n                {\n                    if(lastProcess < numProcesses && sorted[lastProcess].arrivalTime <= currTime)\n                    {\n                        q1.push(sorted[lastProcess]);\n                        lastProcess++;\n                    }\n                    q1.push(temp);\n                }\n            }\n        }\n        else if(WorkingQueue == 1)\n        {\n            if(q2[0].remainingTime <= q2quantum)\n            {\n                currTime += q2[0].remainingTime;\n                s-=q2[0].remainingTime;\n                q2[0].remainingTime = 0;\n                TurnAroundTime = currTime - q2[0].arrivalTime;\n                result.AverageTurnAroundTime += currTime - q2[0].arrivalTime;\n                result.AverageWaitTime += TurnAroundTime - q2[0].burstTime;\n\n                result.timeline.push({time: currTime, process: q2[0].pid});\n                q2[0].completed = true;\n                completedProcesses++;\n                q2.shift();\n            }\n            else\n            {\n                currTime += q2quantum;\n                s-=q2quantum;\n                q2[0].remainingTime -= q2quantum;\n                result.timeline.push({time: currTime, process: q2[0].pid});\n                const temp : Process = q2[0];\n                q2.push(temp);\n                q2.shift();\n                if((temp.burstTime - temp.remainingTime) % allotment == 0)\n                {\n                    temp.queuelevel++;\n                    q3.push(temp);\n                }\n                else\n                {\n                    q2.push(temp);\n                }\n            }\n        }\n        else\n        {\n            if(q3.length > 0 && q3[0].remainingTime > 0)\n            {\n                currTime += q3[0].remainingTime;\n                s-=q3[0].remainingTime;\n                q3[0].remainingTime = 0;\n                result.timeline.push({time: currTime, process: q3[0].pid});\n                q3[0].completed = true;\n                completedProcesses++;\n                q3.shift();\n            }\n            else\n            {\n                currTime += 1;\n                s-=1;\n                result.timeline.push({time: currTime, process: 0});\n            }\n        }\n\n        if(s <= 0)\n        {\n            s = 20;\n            for(let i = 0; i<q2.length; i++)\n            {\n                const temp : Process = q2[0];\n                q1.push(temp);\n                q2.shift();\n            }\n            for(let i = 0; i<q3.length; i++)\n            {\n                const temp : Process = q3[0];\n                q1.push(temp);\n                q3.shift();\n            }\n        }\n    }\n    \n    result.AverageTurnAroundTime = result.AverageTurnAroundTime/numProcesses;\n    result.AverageWaitTime = result.AverageWaitTime/numProcesses;\n    return result\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 978, "column": 0}, "map": {"version":3,"sources":["file:///Users/minhtran/Desktop/College%20stuff/5th%20Semester%20%28Spring%202025%29/Operating%20Systems%20%28CS%20540%29/scheduling-algorithms-project/src/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect, useRef } from \"react\";\nimport GanttChart from \"./GanttChart\";\nimport Table from \"./Table\";\nimport BarChart from \"./BarChart\";\nimport { PDF } from \"../utilities/PDF\";\nimport { generateProcesses } from \"../utilities/processGenerator\";\nimport { Process, Result } from \"../types/process\";\nimport { FirstInFirstOut } from \"../algorithms/fifo\";\nimport { sjf } from \"../algorithms/sjf\";\nimport { rr } from \"../algorithms/rr\";\nimport { stcf } from \"../algorithms/stcf\";\nimport { mlfq } from \"../algorithms/mlfq\";\n\nexport default function Home() {\n  const algorithms = [\n    { name: \"FIFO\", value: \"FIFO\" },\n    { name: \"SJF\", value: \"SJF\" },\n    { name: \"RR\", value: \"RR\" },\n    { name: \"STCF\", value: \"STCF\" },\n    { name: \"MLFQ\", value: \"MLFQ\" }\n  ];\n\n  const [numProcesses, setNumProcesses] = useState<number>(5);\n  const [quantum, setQuantum] = useState<number>(3);\n  const [selectedAlgorithms, setSelectedAlgorithms] = useState<string[]>([]);\n  const [processes, setProcesses] = useState<Process[]>([]);\n  const [results, setResults] = useState<{ [key: string]: Result }>({});\n\n  const waitTimeChartRef = useRef<HTMLCanvasElement>(null);\n  const turnaroundTimeChartRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    setProcesses(generateProcesses(numProcesses));\n  }, [numProcesses]);\n\n  useEffect(() => {\n    if (processes.length === 0) return;\n\n    const newResults: { [key: string]: Result } = {};\n    selectedAlgorithms.forEach((algorithm) => {\n      const processesCopy = JSON.parse(JSON.stringify(processes)); // Deep copy to avoid mutation\n      let resultFromAlgorithm: Result = { timeline: [], AverageWaitTime: 0, AverageTurnAroundTime: 0 };\n\n      switch (algorithm) {\n        case 'FIFO':\n          resultFromAlgorithm = FirstInFirstOut(processesCopy);\n          break;\n        case 'SJF':\n          resultFromAlgorithm = sjf(processesCopy);\n          break;\n        case 'RR':\n          resultFromAlgorithm = rr(processesCopy, quantum);\n          break;\n        case 'STCF':\n          resultFromAlgorithm = stcf(processesCopy);\n          break;\n        case 'MLFQ':\n          resultFromAlgorithm = mlfq(processesCopy);\n          break;\n      }\n\n      newResults[algorithm] = resultFromAlgorithm;\n    });\n\n    setResults(newResults);\n  }, [selectedAlgorithms, processes, quantum]);\n\n  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const { value, checked } = event.target;\n    setSelectedAlgorithms((prev) =>\n      checked ? [...prev, value] : prev.filter((algorithm) => algorithm !== value)\n    );\n  };\n\n  const handleGeneratePDF = () => {\n    PDF(waitTimeChartRef.current, turnaroundTimeChartRef.current);\n  };\n\n  return (\n    <div style={{ padding: \"0px\", backgroundColor: \"#000000\", minHeight: \"100vh\" }}>\n      <div style={{ textAlign: \"center\", marginBottom: \"20px\" }}>\n        <label htmlFor=\"numProcesses\" style={{ color: \"#fff\", marginRight: \"10px\" }}>Number of Processes:</label>\n        <input\n          id=\"numProcesses\"\n          type=\"number\"\n          value={numProcesses}\n          onChange={(e) => setNumProcesses(Number(e.target.value))}\n          style={{ padding: \"5px\", width: \"50px\" }}\n        />\n      </div>\n\n      <div style={{ textAlign: \"center\", marginBottom: \"20px\" }}>\n        <label htmlFor=\"quantum\" style={{ color: \"#fff\", marginRight: \"10px\" }}>Quantum (for RR):</label>\n        <input\n          id=\"quantum\"\n          type=\"number\"\n          value={quantum}\n          onChange={(e) => setQuantum(Number(e.target.value))}\n          style={{ padding: \"5px\", width: \"50px\" }}\n        />\n      </div>\n\n      <div style={{ textAlign: \"center\", marginBottom: \"20px\" }}>\n        <button\n          onClick={handleGeneratePDF}\n          style={{\n            padding: \"10px 20px\",\n            backgroundColor: \"#007bff\",\n            color: \"white\",\n            border: \"none\",\n            borderRadius: \"5px\"\n          }}\n        >\n          Generate PDF\n        </button>\n      </div>\n\n      <div style={{ textAlign: \"center\", marginBottom: \"20px\" }}>\n        {algorithms.map((algorithm) => (\n          <label key={algorithm.value} style={{ display: \"block\", margin: \"5px 0\", color: \"#FFFFFF\" }}>\n            <input\n              type=\"checkbox\"\n              value={algorithm.value}\n              checked={selectedAlgorithms.includes(algorithm.value)}\n              onChange={handleCheckboxChange}\n            />\n            {algorithm.name}\n          </label>\n        ))}\n      </div>\n\n      <Table processes={processes} />\n      <BarChart\n        results={results}\n        waitTimeChartRef={waitTimeChartRef}\n        turnaroundTimeChartRef={turnaroundTimeChartRef}\n      />\n\n      {selectedAlgorithms.map((algorithm) => (\n        <GanttChart\n          key={algorithm}\n          algorithm={algorithm}\n          result={results[algorithm]}\n        />\n      ))}\n\n    </div>\n  );\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1274, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}